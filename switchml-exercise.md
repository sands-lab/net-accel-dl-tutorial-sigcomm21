# SwitchML Tutorial Sigcomm21

**Welcome to the hands on tutorial on SwitchML !**

This tutorial will give you a taste of what its like to configure and run SwitchML. It will then walk you through using SwitchML's API in code and how you can compile your own SwitchML applications. Finally, as an additional exercise, you will write your own prepostprocessor to control how the data is loaded and unloaded from user buffers to and from messages/packets.

For simplicity, and since not all of our attendees have a testbed with multiple nodes and a Tofino switch connecting them, we will be using a "dummy" backend that sleeps to simulate  communication and is simple enough to run on a single node on your own personal laptops.

Without further ado, let's get started !

## Prerequisites
The time of the tutorial is very limited, so in order to get the most out of it and to avoid any holdbacks due to slow internet or a slow machine, we encourage you to download needed materials and prepare your setup in advance by following these two simple steps:

 1. Download and install docker on your machine.
 2. Pull the switchml sigcomm image from docker hub by running: 
 `docker pull omaralama/switchml:sigcomm21_exercise`
 in your machine's command line.
 
We also encourage you to browse SwitchML's [documentation](https://switchml.readthedocs.io/en/latest/index.html)  and [source code](https://github.com/p4lang/p4app-switchML) a bit to get a general feel for the project although this is not required to benefit from the tutorial or to complete all exercises.

## Ex.1 Compile SwitchML and Microbenchmark (4 min)

#### 1.1 Start the docker container
Alright, first thing to do if you haven't already is start a container from the image that we pulled earlier. To do that you can run 

    docker run -it --name switchml omaralama/switchml:sigcomm21_exercise 

This should start a container from the image you had pulled earlier and you should be in a new shell inside that container.

#### 1.2 Compile the SwitchML client library
Next navigate to where we have predownloaded switchml for you. Then go to the `dev_root` directory where all of the source code is located (We will list all of our paths starting tfrom this directory).

	cd /home/switchml/dev_root

Next let us compile the SwitchML client library. The client library is required to compile all examples, benchmarks, framework integrations. To do that go to the `client_lib` directory and run `make`.

	cd client_lib
	make

This will give us the switchml client library and since we did not provide the Makefile with neither DPDK=1 nor RDMA=1, it will only include the dummy backend. Verify that the library has been generated by listing the contents of `dev_root/build/lib`. 

	ls ../build/lib/

It should include `libswitchml-client.a`

#### 1.3 Compile the SwitchML allreduce benchmark.

Now that we have switchml's client library compiled, we can go ahead and compile the microbenchmark.
Navigate to `dev_root/benchmarks` and run `make`.

	cd ../benchmarks
	make

This should generate an allreduce_benchmark binary in `dev_root/build/bin`

To verify that everything is working navigate to `dev_root/build/bin` and print the benchmark's help message.

    cd ../build/bin
    ./allreduce_benchmark --help

If you do not encounter any errors and you see the benchmark message then you are all set.

## Ex.2: Configure and Run Microbenchmark (10 min)
For this exercise we want to run the microbenchmark with different configurations and arguments and see how that effects performance.

#### 2.1. Copy configuration file to working directory
Firstly, for any SwitchML application to run, we need to copy a configuration file to our working directory. A default configuration file is always generated with any SwitchML build that includes only applicable options to that build. You can find it as `/home/switchml/dev_root/build/switchml.cfg`.

Go ahead and copy it to our bin folder `cp ../switchml.cfg .`
   
#### 2.2. Edit configuration

Now let us open up the copied config and perform the following edits:
1. Set `num_worker_threads=1` to start out with 1 worker thread.
2. Set `packet_numel=131072` to start out with a big packet which reduces some processing on the dummy backend.
(Remember nothing is being sent with the dummy so we can make this arbitrarily big)

The container has `vim` and `nano` at hand to perform these edits but feel free to quickly install your favorite editor if you like.

#### 2.3. Run Benchmark
Now that we have our configuration ready, we can run the benchmark with different arguments.

As with the first exercise, feel free to print the help message to read through all available arguments.

But for now we can simply change the number of elements in each tensor that we want to aggregate and observe its effect on performance. And lets use floating point tensors for example.

Run:

    ./allreduce_benchmark --tensor-type float --tensor-numel 10000

At this point you should have some throughput statistics printed out. If you don't then please contact one of the organizers. 

Make a note of the mean throughput and try to run 3 different times with different number of elements and see if that is affecting your performance.

Record all your results in a table.

#### 2.4. Try out different configurations and arguments

Go back to step 2.2 and edit your configuration increasing the number of worker threads from 1 to 4 to 8. And test out each configuration with different number of elements. How is increasing the number of threads affecting the performance? Any trends? compare with your previously recorded results.

#### That's it !
You have successfully run SwitchML. The RDMA and DPDK backends are as easy to run assuming you have setup the switch side correctly. Each backend has its own simple configuration.

If time permits feel free to play around with other configurations or arguments, record and plot your results, and deduce relationships and correlations.

## Ex.3: Write your own SwitchML application (11 min)

In this exercise, we will create our own small SwitchML benchmark from scratch. 
The objective is to perform the following

 1. Allocate a local buffer.
 2. Start the SwitchML context and get its handle.
 3. Submit a synchronous allreduce job to reduce the local buffer's data
 4. Report how much time that took.
 5. Submit an asynchronous allreduce job to reduce the same local buffer's data.
 6. Report how much time that took.
 7. Wait for the job to actually finish.
 8. Report how much time that took.
 9. Stop the context. 

  
#### 3.1 Writing the application

To start with let us create a new directory in `dev_root/examples` with our name.

	mkdir your_name
	cd your_name
	pwd

`pwd` should print `/home/switchml/dev_root/benchmarks/your_name`

Now we will create our `main.cc` file using `vim main.cc` and start writing our own application.  Copy the following template over to your new `main.cc` file as a starting point. ( You may need to copy the code to a notepad first to get rid of any formatting).

	// TODO(1): Include switchml's context header


	#include <stdio.h>
	#include <chrono>

	typedef std::chrono::steady_clock clk;

	int main() {
		std::chrono::time_point<clk> begin, end;
		
		// TODO(2): Get a reference to the context
		// (First time this is called the context will be created)


		printf("Hello from %s, this is %s's SwitchML benchmark.\n",
			   "<Your country>", "<Your name>");

		// TODO(3): Start the context
		// This loads configuration and starts all worker threads 


		printf("I am allocating a tensor\n");
		float* our_data = new float[1<<24]; // 64 MB tensor. Feel free to change this.

		begin = clk::now();

		// TODO(4) Submit synchronous allreduce job.


		end = clk::now();

		printf("Synchronous allreduce call took %ld ns.\n",
				std::chrono::duration_cast<std::chrono::nanoseconds>(end - begin).count());

		begin = clk::now();

		// TODO(5) Submit asynchronous allreduce job and store its job handle.


		end = clk::now();

		printf("Asynchronous allreduce call took %ld ns.\n",
				std::chrono::duration_cast<std::chrono::nanoseconds>(end - begin).count());

		begin = clk::now();

		// TODO(6) Wait for the job you submitted to finish.


		end = clk::now();

		printf("Asynchronous allreduce waiting for the job took %ld ns.\n",
				std::chrono::duration_cast<std::chrono::nanoseconds>(end - begin).count());

		// TODO(7) Stop the switchml context

		delete [] our_data;
	}

Consult SwitchML's Context API [documentation](https://switchml.readthedocs.io/en/latest/client_lib_api/classswitchml_1_1Context.html#exhale-class-classswitchml-1-1context) and the [hello_world](https://github.com/p4lang/p4app-switchML/blob/main/dev_root/examples/hello_world/main.cc) example located in `dev_root/examples/hello_world`. To continue the exercise 

#### 3.2 Compile the application
Once you are ready to test your application, it is time for compilation. SwitchML has multiple libraries that it needs to link to at the final compilation stage. Thus, we have to use the examples makefile and edit it slightly to include our new application.
1. Open up `dev_root/examples/Makefile`
2. Locate the following lines at the end of the file:

       hello_world: $(BINDIR)/hello_world
       
       $(BINDIR)/hello_world: $(BINDIR)
	       $(CXX) $(CXXFLAGS) $(INC) $(SRCDIR)/hello_world/main.cc $(LDFLAGS) -o $(BINDIR)/hello_world 
3. Duplicate these lines replacing all hello_world strings with the name of your application.

       your_name: $(BINDIR)/your_name
       
       $(BINDIR)/your_name: $(BINDIR)
	       $(CXX) $(CXXFLAGS) $(INC) $(SRCDIR)/your_name/main.cc $(LDFLAGS) -o $(BINDIR)/your_name

That's it. Save your file and quit. You can now compile your application by running `make your_name` in the `dev_root/examples` directory.

Assuming your application was written correctly the first time the compilation should finish without any errors. However, we all know that this is a far fetched assumption :D. So when an error pops up, go back, fix it, and try again.

Once the compilation completes with no errors, then make sure your application's binary has been generated in `dev_root/build/bin`.

#### 3.3 Run your application

Just like the second exercise, copy the switchml configuration over if its not already there, and run your application. If you survive segmentation faults on your first run then congratulations. If not go back, debug, remove old benchmark binary, compile, and test again.

Once you start seeing meaningful results, record them and compare synchronous calls with asynchronous calls and waits. 

If you are ahead, then you can go back to your source code and add more jobs, change the size of the buffer, or add verification code. Then compile again and test your changes.


## Kudos !
Congratulations ! you have successfully, compiled, configured, and ran SwitchML. You have also written, compiled, and tested your own small benchmark. 

We hope that the tutorial was useful to you and that it showed you how easy it is to use and build on top of SwitchML. 

Don't hesitate to contact the SwitchML team if you have any questions.
